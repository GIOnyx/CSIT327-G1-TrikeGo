{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Driver Dashboard - TrikeGo</title>
    <link rel="stylesheet" href="{% static 'user/css/driver_dashboard.css' %}" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
</head>
<body {% if active_booking %}data-active-booking-id="{{ active_booking.id }}"{% endif %}>
    <div class="header">
        <h1>Driver Dashboard</h1>
        <a href="{% url 'user:landing' %}" class="logout-btn">Logout</a>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="dashboard-profile-card">
                <h2>Welcome, {{ user.first_name }} {{ user.last_name }}!</h2>
                <p>Driver ID: {{ user.username }}</p>
            </div>

            <div class="dashboard-quickaction-card">
                <h3>Quick Actions</h3>
                <div class="action-buttons">
                    <a href="{% url 'user:driver_active_books' %}" class="btn btn-primary">View My Rides</a>
                    <a href="#" class="btn btn-secondary">Update Profile</a>
                </div>
            </div>
            
            {% if driver_profile %}
            <div class="dashboard-profile-card">
                <h3>Profile</h3>
                <p><strong>Status:</strong> {{ driver_profile.status }}</p>
                <p><strong>Verified:</strong> {{ driver_profile.is_verified|yesno:"Yes,No" }}</p>
            </div>
            {% endif %}

            {% if active_booking %}
            <div class="dashboard-tracking-card">
                <h3>Live ETA</h3>
                <p><strong id="eta-label">Time to Pick-up:</strong> <span id="eta-value">Calculating...</span></p>
            </div>
            {% endif %}
        </div>

        <div class="main-content">
            <div class="dashboard-activity-card">
                <h3>Available Rides</h3>
                {% if available_rides %}
                    <ul class="ride-list">
                        {% for ride in available_rides %}
                            <li class="ride-item">
                                <strong>From:</strong> {{ ride.pickup_address }}<br>
                                <strong>To:</strong> {{ ride.destination_address }}<br>
                                <small>Requested: {{ ride.booking_time|date:"M d, Y H:i" }}</small>
                                <div class="ride-actions">
                                    <button class="btn btn-secondary review-ride-btn" data-booking-id="{{ ride.id }}">
                                        Review
                                    </button>
                                    <form method="POST" action="{% url 'user:accept_ride' ride.id %}" style="display: inline;">
                                        {% csrf_token %}
                                        <button type="submit" class="btn btn-success">Accept Ride</button>
                                    </form>
                                </div>
                            </li>
                        {% endfor %}
                    </ul>
                {% else %}
                    <p>No rides available right now.</p>
                {% endif %}
            </div>
            
            <div class="dashboard-section">
                <h2>Ride Preview</h2>
                <div id="map-container">
                    <div class="map-legend" id="map-legend-driver" aria-hidden="false">
                        <div class="legend-item"><span class="legend-dot driver"></span>Driver</div>
                        <div class="legend-item"><span class="legend-dot pickup"></span>Pickup / Rider</div>
                        <div class="legend-item"><span class="legend-dot dest"></span>Destination</div>
                    </div>
                </div>
                <div id="route-details">Click 'Review' on a ride to see the route details here.</div>
                <div id="active-trip-eta" style="display:none; margin-top: 15px; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                    <p><strong id="eta-label">Time to Pick-up:</strong> <span id="eta-value">Calculating...</span></p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        function startActiveBookingDisplay(bookingId, mapInstance) {
            const ORS_API_KEY = '{{ settings.OPENROUTESERVICE_API_KEY }}' || '5b3ce3597851110001cf62488c26abeb';
            const etaLabel = document.getElementById('eta-label');
            const etaValue = document.getElementById('eta-value');
            
            console.log('Starting active booking route display for booking:', bookingId);
            
            // Show the ETA section
            const etaSection = document.getElementById('active-trip-eta');
            if (etaSection) {
                etaSection.style.display = 'block';
            }
            
            let activeDriverToRiderRouteLayer = null;
            let activeRiderToDestRouteLayer = null;
            // Markers for active booking view
            let activeDriverMarker = null;
            let activePickupMarker = null;
            let activeDestMarker = null;

            async function refreshEtaAndRoute() {
                try {
                    const infoResponse = await fetch(`/api/booking/${bookingId}/route_info/`);
                    const info = await infoResponse.json();
                    if (info.status !== 'success') {
                        console.error('Route info error:', info.message);
                        return;
                    }
                    
                    console.log('Active booking route info:', info);
                    
                    const dLat = Number(info.driver_lat), dLon = Number(info.driver_lon);
                    const pLat = Number(info.pickup_lat), pLon = Number(info.pickup_lon);
                    const xLat = Number(info.destination_lat), xLon = Number(info.destination_lon);
                    
                    console.log('Active booking coordinates:', { dLat, dLon, pLat, pLon, xLat, xLon });
                    
                    // Always show both routes for accepted bookings
                    if (Number.isFinite(dLat) && Number.isFinite(dLon) && Number.isFinite(pLat) && Number.isFinite(pLon)) {
                        console.log('Fetching driver to pickup route...');
                        const dtUrl = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${ORS_API_KEY}&start=${dLon},${dLat}&end=${pLon},${pLat}`;
                        const dtRes = await fetch(dtUrl);
                        const dt = await dtRes.json();
                        console.log('Driver to pickup route response:', dt);
                        
                        if (dt.features?.[0]?.properties?.segments?.[0]) {
                            etaLabel.textContent = 'Time to Pick-up:';
                            const seg = dt.features[0].properties.segments[0];
                            etaValue.textContent = `${Math.ceil(seg.duration / 60)} min`;
                            
                            // Show driver to pickup route
                            if (activeDriverToRiderRouteLayer) mapInstance.removeLayer(activeDriverToRiderRouteLayer);
                            activeDriverToRiderRouteLayer = L.geoJSON(dt.features[0], {
                                style: { color: '#28a745', weight: 5, opacity: 0.8 }
                            }).addTo(mapInstance);
                            console.log('Added driver to pickup route');

                            // Update/create driver marker
                            try {
                                const driverLatLng = [dLat, dLon];
                                    const driverIcon = L.divIcon({ className: 'driver-marker', html: '<div class="marker-inner"></div>', iconSize: [30, 30] });
                                if (activeDriverMarker) {
                                    activeDriverMarker.setLatLng(driverLatLng);
                                } else {
                                    activeDriverMarker = L.marker(driverLatLng, { icon: driverIcon }).addTo(mapInstance).bindPopup('Driver');
                                }
                            } catch (mErr) {
                                console.warn('Failed to create/update active driver marker', mErr);
                            }
                        }
                    }
                    
                    // Always show pickup to destination route for accepted bookings
                    if (Number.isFinite(pLat) && Number.isFinite(pLon) && Number.isFinite(xLat) && Number.isFinite(xLon)) {
                        console.log('Fetching pickup to destination route...');
                        const rdUrl = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${ORS_API_KEY}&start=${pLon},${pLat}&end=${xLon},${xLat}`;
                        const rdRes = await fetch(rdUrl);
                        const rd = await rdRes.json();
                        console.log('Pickup to destination route response:', rd);
                        
                        if (rd.features?.[0]?.properties?.segments?.[0]) {
                            // Show pickup to destination route
                            if (activeRiderToDestRouteLayer) mapInstance.removeLayer(activeRiderToDestRouteLayer);
                            activeRiderToDestRouteLayer = L.geoJSON(rd.features[0], {
                                style: { color: '#007bff', weight: 5, opacity: 0.8 }
                            }).addTo(mapInstance);
                            console.log('Added pickup to destination route');

                            // Update/create pickup and destination markers
                            try {
                                const pickupLatLng = [pLat, pLon];
                                const destLatLng = [xLat, xLon];
                                    const pickupIcon = L.divIcon({ className: 'pickup-marker', html: '<div class="marker-inner"></div>', iconSize: [25, 25] });
                                    const destIcon = L.divIcon({ className: 'dest-marker', html: '<div class="marker-inner"></div>', iconSize: [25, 25] });

                                if (activePickupMarker) {
                                    activePickupMarker.setLatLng(pickupLatLng);
                                } else {
                                    activePickupMarker = L.marker(pickupLatLng, { icon: pickupIcon }).addTo(mapInstance).bindPopup('Pickup Location');
                                }

                                if (activeDestMarker) {
                                    activeDestMarker.setLatLng(destLatLng);
                                } else {
                                    activeDestMarker = L.marker(destLatLng, { icon: destIcon }).addTo(mapInstance).bindPopup('Destination');
                                }
                            } catch (mErr) {
                                console.warn('Failed to create/update active pickup/dest markers', mErr);
                            }
                            
                            // Update ETA to destination if trip has started
                            if (info.booking_status === 'started') {
                                etaLabel.textContent = 'Time to Destination:';
                                const seg = rd.features[0].properties.segments[0];
                                etaValue.textContent = `${Math.ceil(seg.duration / 60)} min`;
                            }
                        }
                    }
                    
                    // Fit map to show all routes
                    const layers = [];
                        if (activeDriverToRiderRouteLayer) layers.push(activeDriverToRiderRouteLayer);
                    if (activeRiderToDestRouteLayer) layers.push(activeRiderToDestRouteLayer);
                    if (layers.length > 0) {
                        let bounds = layers[0].getBounds();
                        layers.forEach(l => bounds.extend(l.getBounds()));
                        mapInstance.fitBounds(bounds, { padding: [50, 50] });
                    }

                    // Debug: log marker + DOM state after refreshing routes
                    try {
                        const markers = Array.from(document.querySelectorAll('.leaflet-marker-icon, .leaflet-div-icon'));
                        console.log('[DEBUG] Leaflet marker DOM count (active booking refresh):', markers.length, markers.slice(0,5));
                        markers.forEach((m, i) => {
                            console.log(`[DEBUG] marker[${i}]`, {
                                class: m.className,
                                styles: window.getComputedStyle(m),
                                rect: m.getBoundingClientRect()
                            });
                        });
                    } catch (err) {
                        console.warn('[DEBUG] failed to inspect markers DOM', err);
                    }
                } catch (e) {
                    console.error('ETA refresh error', e);
                }
            }
            refreshEtaAndRoute();
            setInterval(refreshEtaAndRoute, 5000);
        }

        document.addEventListener('DOMContentLoaded', function() {
            const ORS_API_KEY = '{{ settings.OPENROUTESERVICE_API_KEY }}' || '5b3ce3597851110001cf62488c26abeb';

            const map = L.map('map-container').setView([10.3157, 123.8854], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Default map to driver's GPS
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition((pos) => {
                    map.setView([pos.coords.latitude, pos.coords.longitude], 15);
                }, () => {}, { enableHighAccuracy: true, timeout: 5000 });
            }

            // Active booking ETA updater and route display - moved here after map is initialized
            const activeBookingId = document.body.getAttribute('data-active-booking-id');
            console.log('Active booking ID from data attribute:', activeBookingId);
            
            if (activeBookingId) {
                console.log('Found active booking, starting route display...');
                startActiveBookingDisplay(activeBookingId, map);
            } else {
                console.log('No active booking ID found in data attribute, checking for active booking via API...');
                // Try to find active booking via API call
                fetch('/api/driver/active-booking/')
                    .then(response => response.json())
                    .then(data => {
                        if (data.booking_id) {
                            console.log('Found active booking via API:', data.booking_id);
                            startActiveBookingDisplay(data.booking_id, map);
                        } else {
                            console.log('No active booking found via API');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching active booking:', error);
                    });
            }

            let driverToRiderRouteLayer, riderToDestRouteLayer;
            let pickupMarker, destMarker, driverMarker;
            const routeDetailsContainer = document.getElementById('route-details');
            const reviewButtons = document.querySelectorAll('.review-ride-btn');

            reviewButtons.forEach(button => {
                button.addEventListener('click', async function() {
                    const bookingId = this.dataset.bookingId;
                    routeDetailsContainer.innerHTML = "Fetching route information...";

                    try {
                        const infoResponse = await fetch(`/api/booking/${bookingId}/route_info/`);
                        const routeInfo = await infoResponse.json();
                        if (routeInfo.status !== 'success') throw new Error(routeInfo.message);
                        
                        if (driverToRiderRouteLayer) map.removeLayer(driverToRiderRouteLayer);
                        if (riderToDestRouteLayer) map.removeLayer(riderToDestRouteLayer);
                        if (pickupMarker) map.removeLayer(pickupMarker);
                        if (destMarker) map.removeLayer(destMarker);
                        if (driverMarker) map.removeLayer(driverMarker);

                        // Only create driver marker if driver coordinates are available and numeric
                        const driverLatVal = routeInfo.driver_lat;
                        const driverLonVal = routeInfo.driver_lon;
                        const hasDriverCoords = (driverLatVal != null && driverLonVal != null && Number.isFinite(Number(driverLatVal)) && Number.isFinite(Number(driverLonVal)));
                        if (hasDriverCoords) {
                            const driverLatLng = [Number(driverLatVal), Number(driverLonVal)];
                            const driverIcon = L.divIcon({ className: 'driver-marker', html: '<div class="marker-inner"></div>', iconSize: [30, 30] });
                            driverMarker = L.marker(driverLatLng, { icon: driverIcon }).addTo(map).bindPopup('Your Location');
                        } else {
                            // No driver location available for preview — inform the user and proceed with pickup->destination only
                            console.warn('Driver coordinates not available for preview:', driverLatVal, driverLonVal);
                        }

                        const pickupLatLng = [routeInfo.pickup_lat, routeInfo.pickup_lon];
                        const destLatLng = [routeInfo.destination_lat, routeInfo.destination_lon];
                        const pickupIcon = L.divIcon({ className: 'pickup-marker', html: '<div class="marker-inner"></div>', iconSize: [25, 25] });
                        const destIcon = L.divIcon({ className: 'dest-marker', html: '<div class="marker-inner"></div>', iconSize: [25, 25] });
                        pickupMarker = L.marker(pickupLatLng, { icon: pickupIcon }).addTo(map).bindPopup('Pickup Location');
                        destMarker = L.marker(destLatLng, { icon: destIcon }).addTo(map).bindPopup('Destination');

                        // Only request driver->pickup route when we have driver coords
                        let dtUrl = null;
                        if (hasDriverCoords) {
                            dtUrl = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${ORS_API_KEY}&start=${routeInfo.driver_lon},${routeInfo.driver_lat}&end=${routeInfo.pickup_lon},${routeInfo.pickup_lat}`;
                        }
                        const rdUrl = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${ORS_API_KEY}&start=${routeInfo.pickup_lon},${routeInfo.pickup_lat}&end=${routeInfo.destination_lon},${routeInfo.destination_lat}`;
                        // Fetch rd always; fetch dt only if dtUrl present
                        const rdResponse = await fetch(rdUrl);
                        const rdResult = await rdResponse.json();
                        let dtResult = null;
                        if (dtUrl) {
                            const dtResponse = await fetch(dtUrl);
                            dtResult = await dtResponse.json();
                        }
                        
                        if (dtResult && dtResult.features && dtResult.features.length > 0) {
                            const dtRoute = dtResult.features[0];
                            driverToRiderRouteLayer = L.geoJSON(dtRoute, { style: { color: '#28a745', weight: 5, opacity: 0.8 } }).addTo(map);
                        }
                        if (rdResult.features && rdResult.features.length > 0) {
                            const rdRoute = rdResult.features[0];
                            riderToDestRouteLayer = L.geoJSON(rdRoute, { style: { color: '#007bff', weight: 5, opacity: 0.8 } }).addTo(map);
                        }
                        const allLayers = [];
                        if (driverToRiderRouteLayer) allLayers.push(driverToRiderRouteLayer);
                        if (riderToDestRouteLayer) allLayers.push(riderToDestRouteLayer);
                        if (allLayers.length > 0) {
                            let bounds = allLayers[0].getBounds();
                            allLayers.forEach(layer => bounds.extend(layer.getBounds()));
                            map.fitBounds(bounds, { padding: [50, 50] });
                        }

                        // Show ETA to pickup in preview panel
                        const etaLabel = document.getElementById('eta-label');
                        const etaValue = document.getElementById('eta-value');
                        if (etaLabel && etaValue) {
                            if (dtResult && dtResult.features?.[0]?.properties?.segments?.[0]) {
                                etaLabel.textContent = 'Time to Pick-up:';
                                const seg = dtResult.features[0].properties.segments[0];
                                etaValue.textContent = `${Math.ceil(seg.duration / 60)} min`;
                            } else if (routeInfo.driver_to_pickup_km != null) {
                                // Use server-provided estimated distance as fallback (no ETA seconds available)
                                etaLabel.textContent = 'Est. Dist to Pickup:';
                                etaValue.textContent = `${routeInfo.driver_to_pickup_km} km`;
                            } else {
                                etaLabel.textContent = 'Time to Pick-up:';
                                etaValue.textContent = '--';
                            }
                        }

                        routeDetailsContainer.innerHTML = 'Preview loaded.';

                        // Debug: log marker + DOM state after loading preview
                        try {
                            const markers = Array.from(document.querySelectorAll('.leaflet-marker-icon, .leaflet-div-icon'));
                            console.log('[DEBUG] Leaflet marker DOM count (review preview):', markers.length, markers.slice(0,5));
                            markers.forEach((m, i) => {
                                console.log(`[DEBUG] preview marker[${i}]`, {
                                    class: m.className,
                                    styles: window.getComputedStyle(m),
                                    rect: m.getBoundingClientRect()
                                });
                            });
                        } catch (err) {
                            console.warn('[DEBUG] failed to inspect markers DOM (preview)', err);
                        }
                    } catch (error) {
                        console.error("ORS Routing error:", error);
                        routeDetailsContainer.innerHTML = `<p style="color: #dc3545;">Could not calculate the route. ${error.message}</p>`;
                    }
                });
            });
        });
    </script>

    <script>
    // Driver Location Broadcasting System
    let locationWatchId = null;
    let isTracking = false;

    document.addEventListener('DOMContentLoaded', function() {
        const activeBookingId = document.body.getAttribute('data-active-booking-id');
        if (activeBookingId) {
            // Force enable tracking and persist across refresh
            startLocationTracking(true);
            localStorage.setItem('driverTracking', 'force');
        } else {
            // Restore previous session
            if (localStorage.getItem('driverTracking') === 'true') {
                startLocationTracking(false);
            }
        }
    });

    function startLocationTracking(force) {
        if (!navigator.geolocation) {
            alert('Geolocation is not supported by your browser');
            return;
        }
        const options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 };
        locationWatchId = navigator.geolocation.watchPosition(handleLocationUpdate, handleLocationError, options);
        isTracking = true;
        // Disable manual stop during active trip
        const activeBookingId = document.body.getAttribute('data-active-booking-id');
        if (activeBookingId && force) {
            lockTrackingUI(true);
        }
    }

    function stopLocationTracking() {
        const activeBookingId = document.body.getAttribute('data-active-booking-id');
        if (activeBookingId) {
            // Prevent stopping when an active trip exists
            lockTrackingUI(true);
            return;
        }
        if (locationWatchId !== null) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
        isTracking = false;
        localStorage.setItem('driverTracking', 'false');
    }

    function lockTrackingUI(locked) {
        let statusDiv = document.getElementById('location-status');
        if (!statusDiv) {
            statusDiv = document.createElement('div');
            statusDiv.id = 'location-status';
            statusDiv.style.cssText = 'position: fixed; top: 70px; right: 20px; padding: 10px 15px; border-radius: 4px; color: white; font-size: 14px; z-index: 1000;';
            document.body.appendChild(statusDiv);
        }
        statusDiv.style.backgroundColor = locked ? '#28a745' : '#6c757d';
        statusDiv.textContent = locked ? 'Location Sharing Active (locked during trip)' : 'Location Sharing';
    }

    async function handleLocationUpdate(position) {
        const locationData = {
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            accuracy: position.coords.accuracy,
            heading: position.coords.heading,
            speed: position.coords.speed
        };
        try {
            const response = await fetch('/api/driver/update_location/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCookie('csrftoken') },
                body: JSON.stringify(locationData)
            });
            if (!response.ok) throw new Error('Failed to update location');
            const activeBookingId = document.body.getAttribute('data-active-booking-id');
            if (!activeBookingId && isTracking) {
                localStorage.setItem('driverTracking', 'true');
            }
        } catch (error) {
            console.error('Error updating location:', error);
        }
    }

    function handleLocationError(error) {
        console.error('Geolocation error:', error);
    }

    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Hooks for buttons/forms if needed: prevent stopping during trip
    document.addEventListener('click', function(e) {
        const activeBookingId = document.body.getAttribute('data-active-booking-id');
        if (!activeBookingId) return;
        if (e.target && e.target.id === 'location-toggle-stop') {
            e.preventDefault();
            lockTrackingUI(true);
        }
    });

    </script>
</body>
</html>